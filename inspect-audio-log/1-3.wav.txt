openai/whisper-small
Default Decoding Strategy
 자 이번 시간에는 분산 버전 관리 시스템에 대해서 이해를 해볼게요 전 시간에 배운게 협업을 위해서 CVCVCS 라고 해서 중앙 관리, 중앙에서 관리하는 시스템 이거를 전 시간에 배어요. 이제 이게 협업이 되는데 단점은 뭐냐면 중앙 저장소가 고장이 나면 협업이 안되요. 그리고 얘는 이제 제이 마지막 끝점이라고 하는데 엔드 포인트 이 끝점만 이 변경을 기록하기 때문에 끝점에 대한 변경을 기록한다는 게 무슨 말이냐면 봐봐요 내가 이제vcs 이 저정소에다가 중�를 넣어놓은거죠. 그래서 얘를 버전1이라고 하는거예요. 얘도 이제 이걸 다운받아서 동계화가 되어 있는 상태거든요. 자 이 상태에서 내가 이제 데이터를 변 이제 1안영에 이 반가워가 들어왔다는 이 스토리를 들고 있어요 근데 얘네들은 그런 스토리를 안 들고 있거든요 얘도 몰라요 그 스토리를 얘는 왜 모르냐면 이제 얘가 이제 반가워를 업로드해서 얘가 반가워 데이터가 됐잖아요? 그럼 얘가 이제 이걸 내려받으면 그냥 이 file 2.txt가 덮어 씌워지는 개념이거든요 덮어 쓰기를 한다는 개념이에요 그럼 얘는 이제 뭐라 안 되고 있는지 히스토리는 안되고 있는거죠 이게 없다는거에요 얘도 없다는거죠 근데 이제 dvcs 분산 버전 관리 시스템은요 이거는 좀 다른게 내가 이제 5.1.txt들이 되고 있는데 여기 이제 1. 안녕이라고 들고 있는 거에요. 그럼 이제 내가 1 안녕이라고 들고 있으니까 이거를 버전은 로컬에서도 관리를 해야 되거든요. 버전 1이라고 이렇게 관리를 해요. 그리고 나서 이거를 이제 중앙 저장소에 올리는 거죠. 이거를 이제 기덕이라고 생각하시면 돼요. 그래서 기덕에다가 올려요. 그러면 얘가 1 안녕. 그니까 5.0 txt가 얘가 올라오면서 그 내용이 1 안녕 이라고 해서 이걸 버전1 이라고 하는거죠. 첫번째 버전이전이 하나 피어났죠 이 상태에서 이제 얘가 이걸 내려가게 되면 얘가 내려가도 될 때는 다른 애가 pi 1.txt를 내려 받는거 마찬가지인데 얘가 pi 1.txt는 안녕이라는 이 메시지만 가지고 있는게 아니라 version 1이라는 것을 같이 읽고 있어요 이 상태에서 이제 봐봐요 버전2를 만들고 나서 이제 올리는 거죠. 올리게 되면 이제 5.1에 대한 내용이 바뀌잖아요. 그럼 이거를 이제 index라고 하는데 어떤 목차라고 하는데 5.1.txt가 하나 더 생기면서 기존에 있는 게 사라지겠죠. 사라지지만 사라지면서 얘가 이제 1. 안녕해 2, 반가워 라고 해서 1 버전2 라고 해요 이 버전2를 들고 있는거죠 실제로는 이 안녕이라는 데이터 자체는요 중복이 되지 않아요 이거는 어차피 이거 레퍼런스만 참조하는 거기 때문에 이 데이터가 중복되되진 않고요 그냥 눈으로 보기는 이렇게 보인다는 거죠 자 이 상태에서 이제 얘가 다운을 내려봤잖아요 두 번째가 이걸 이제 내려받게 되면 얘는 어떻게 데이터를 내려봤느냐 바이 1.txt에 대한 내용이 바뀌겠죠 얘가 아니라 통으로 바뀌고 그래요 통으로 바. 1.txt는 1, 안녕해. 이 방법. 이렇게. 근데 얘는 이제 버전2잖아요. 그리고 얘를 통으로 관리하고 있습니다. 결국 히스토리를 다 들고 있는 거죠. 얘는 버전1, 버전2 얘도 마찬가지죠 버전1 버전2 그리고 얘도 버전1 버전2 즉 분산 버전 관리 시스템은요 로콜도 히스토리를 다들고 있어 얘도 히스토리를 들고 있고 얘도 히스토리를 들고 있기 때문에 장치를 뭐냐면 얘가 망가지잖아요? 괜찮아요 왜냐면 히스토리를 통해서 로콜에서 복구하는게요. 중앙조정소에 엄청난거에요. 왜냐면 예전에는 여기서는 내가 뭔가 하나를 반영하려면 항상 중앙조정소에다가 업로드를 해야 되거든요. 그래서 이제 관리를 할 수 있거든요. 업로드를 하면서 관리를 하는거에요. 근데 이 관리 자체로 로코를 할 수 있으니까 말 그대로 인터넷이 안됏� 내 컴퓨터 내부에서 로콜로 관리하다가 필요할 때 업로드 하면 돼요 위에다가 이해되시나요? 이게 분산 버전 관리 시스템이에요 그러면 이제 이게 헷갈릴 거예요 궁금한 게 뭐냐면 어 도대체 얘네들은 같은 파일이 있는데 이 같은 파일에 대한 이 관리를 어떤 방식을 하는지 이게 궁금하죠 그쵸 이거에 대한 비밀은 다음 시간에 배워보도록 할게요 여기선은 이제 핵심은 그거예요 분산 버전 관리 시스템은 히스토리를 로컬도 가지고 있다는 거예요. 네, 수고하셨습니다.


openai/whisper-small
Best Decoding Strategy
 자 이번 시간에는 분산 버전 관리 시스템에 대해서 이해를 해볼게요. 전 시간에 배운게 협업을 위해서 cv.. 기억나세요? cvcs 라고 해서 그 중앙 관리.. 중앙에서 관리하는 시스템 이거를 전 시간에 배웠어요. 이제 이게 협업이 되는데 단점은 뭐냐면 중앙 저장소가 고장이 나면 이 협업이 안되요 그리고 얘는 이제 제이 마지막 끝점이라고 하는데 엔드포인트 이 끝점만 이 변경을 기록하기 때문에 끝점에 대한 변경을 기록한다는 게 무슨 말이냐면 봐봐요 내가 이제 파일 1.txt가 있는데 여기 내용이 1 안녕 이렇게 적혀있는 거예요 그리고 이제 다른 사람도 이거 같이 들고 있어요. 자 이 상태에서 이제 내가 여기 cvcs 이 저장소에다가 중앙 저장소에다가 얘를 넣는거죠? 1.txt래 그래서 얘를 버전1이라고 하는거예요. 얘도 이제 이걸 다운받아가지고 동계가 되어 있는 상태거든요 이 상태에서 내가 데이터를 변경을 할건데 이 방거어라는 데이터를 만들었어요 그리고 나서 이제 올리게 되면 얘는 파일 1위 이게 업데이트가 돼서 얘가 날라가고 얘를 버전트라고 하는거죠 대신에 이 중앙조장소는 내부 디비를 두고 있어서 히스토리를 가지고 있어요 히스토리 이 스토리는 원래는 일 안녕이었는데 1안영에 이 반가워가 들어왔다는 이 스토리를 들고 있어요 근데 얘네들은 그런 스토리를 안 들고 있거든요 얘도 몰라요 그 스토리를 얘는 왜 모르냐면 이제 얘가 이제 반가워를 업로드해서 얘가 반가워 데이터가 됐잖아요? 그럼 얘가 이제 이걸 내려받으면 그냥 이 file 2.txt가 덮어 씌워지는 개념이거든요 덮어 쓰기를 한다는 개념이에요 그럼 얘는 이제 뭐라 안 되고 있는지 히스토리는 안되고 있는거죠 이게 없다는거에요 얘도 없다는거죠 근데 이제 dvcs 분산 버전 관리 시스템은요 이거는 좀 다른게 내가 이제 5.1.txt들이 되고 있는데 여기 이제 1. 안녕이라고 들고 있는 거에요. 그럼 이제 내가 1 안녕이라고 들고 있으니까 이거를 버전은 로컬에서도 관리를 해야 되거든요. 버전1이라고 이렇게 관리를 해요. 그리고 나서 이거를 이제 중앙 저장소에 올리는 거죠. 이거는 이제 기덕이라고 생각하시면 돼요. 그래서 기덕에다가 올려요. 그러면 얘가 1, 안녕. 그니까 바일 원정 txt가 얘가 올라오면서 그 내용이 1, 안녕 이라고 해서 이걸 버전1 이라고 하는거죠. 첫번째 버이 하나 피어났죠 이 상태에서 이제 얘가 이걸 내려 받게 되면 얘가 내려 받을 때는 다른 애가 5.1.txt를 내려 받는거 마찬가지인데 얘가 5.1.txt는 안녕이라는 요 메시지만 가지고 있는게 아니라 버전2를 만들고 나서 이제 올리는 거죠. 올리게 되면 이제 5.1에 대한 내용이 바뀌잖아요. 그럼 이거를 이제 인덱스라고 하는데 어떤 목차라고 하는데 5.1.txt가 하나 더 생기면서 기존에 있는 게 사라지겠죠. 사라지지만 사라지면서 얘가 이제 1. 안녕해 2 반가워라고 해서 얘를 버전2라고 해요 이 버전2를 들고 있는 거죠 실제로는 이 안녕이라는 데이터 자체는요 중복이 되지 않아요 이거는 어차피 이거 레퍼런스만 참조하는 거기 때문에 이 데이터가 중복��되진 않고요 그냥 눈으로 보기에는 이렇게 보인다는 거죠 자 이 상태에서 이제 얘가 다운을 내려봤잖아요 두 번째가 이걸 이제 내려받게 되면 얘는 어떻게 데이터를 내려봤느냐 바이 1.txt에 대한 내용이 바뀌겠죠 얘가 아니라 통으로 바뀌고 그래요 통으로 바. 5 1.60은 1, 안녕해. 2, 반거. 이렇게. 근데 얘는 이제 버전2잖아요. 그리고 얘를 통으로 관리하고 있습니다. 결국 히스토리를 다 들고 있는 거죠. 얘는 버전1, 버전2. 얘도가지죠 버전1 버전2 그리고 얘도 버전1 버전2 즉 분산 버전 관리 시스템은요 로콜도 히스토리를 다들고 있어 얘도 히스토리를 들고 있고 얘도 히스토리를 들고 있기 때문에 장치를 뭐냐면 얘가 망가지잖아요? 괜찮아요 왜냐면 히스토리를 통해서 로콜에서 복구하는게요. 중앙조정소에. 엄청난거에요. 왜냐면 예전에는 여기서는 내가 뭔가 하나를 반영하려면 항상 중앙조정소에다가 업로드를 해야 되거든요. 그래서 이제 관리를 할 수 있거든요. 업로드를 하면서 관리를 하는거에요. 근데 이 관리 자체로 로코를 할 수 있으니까 말 그대로 인터넷이 안됏� 내 컴퓨터 내부에서 로콜로 관리하다가 필요할 때 업로드 하면 돼요 위에다가 이해되시나요? 이게 분산 버전 관리 시스템이요 그러면 이제 이게 헷갈릴 거예요 궁금한 게 뭐냐면 도대체 얘네들은 같은 파일이 있는데 이 같은 파일에 대한 갈리를 어떤 방식을 하는지 이게 궁금하죠? 그렇죠? 이거에 대한 비밀은 다음 시간에 배워보도록 할게요. 여기서는 이제 핵심은 그거예요. 분산 버전 갈리 시스템은 히스토리를 로컬도 가지고 있다는 거예요. 네, 수고하셨습니다.


whisper-small-ko-ksponspeech-encoder-freeze-1e-5/checkpoint-9500
Default Decoding Strategy
자 이번 시간에는 그 분산 버전 관리 시스템에 대해서 이해를 해볼께요. 이 전 시간에 배운 게 협업을 위해서 cv 기억나세요? cvcs라고 해서 그 중앙 관리 중앙에서 관리하는 시스템 이거를 전 시간에 배웠어요. 인제 이게 협업이 되는데 단점은 뭐냐면 중앙 저장소고 고장이 나면 이 협업이 안 돼요. 그리고 얘는 이제 제이 마지막 끝점이라고 하는데. 엔드포인트 이 끝점만 이 변경을 기록하기 때문에 끝점에 대한 변경을 기록한다는 게 무슨 말이냐면 봐봐요. 내가 이제 파일 일 점 티엑티가 있는데 여기 여기 내용이 일 안녕 이렇게 적혀 있는 거에요. 그리고 이제 따른 사람도 이거 같이 놀고 있어요. 자 이 상태에서 이제 내가 여기 cvcs 이 저장소에다가 이 중앙 저장소에다가 얘를 넣어논 거죠. 이 점틱스트래. 그래서 얘를 버전 우원이라고 하는 거예요. 금 얘도 이제 이걸 다운받아가지고 동기화가 돼 있는 상태거든요? 짜 이 상태에서 내가 이제 데이터를 변경을 할 건데 이 반거어라는 데이터를 만들었어요. 그리고 나서 이제 올리게 되면 얘는 마일 일이 이게 업데이트가 돼서 얘가 날라가고 얘를 버전 틀어 가는 거죠. 대신에 중앙조장서는 내부 디비를 두고 있어서 히스토리를 가지고 있어 히스토리. 히스토리는 원래는 일 안영이었는데 이제 일 안영에 이 반가워가 들어왔다는 이 스토리를 들고 있어. 근데 얘네들은 그런 히스토리를 안 들고 있거든. 얘도 몰라요. 그 히스토리를. 얘는 왜 모르냐면 이제 얘가 이제 반가워를 업로드해서 얘가 반가워 데이터가 됐잖아요. 금 얘가 이걸 렛을 받으면 그냥 이 파일이 점 티 엑스티가 이 덮어 씌워지는 개념이거든요. 덮어 쓰기를 한다는 개념이에요. 그럼 얘는 이제 뭐라 안고 안 되고 있냐면 히스토리는 안 되고 있는 거죠. 이게 없다는 거예요. 얘도 없다는 거죠. 근데 이제 dvcs 분산 버전 관리 시스템은요. 이거는 좀 다른 게 얘가 이제 바이 원점 티 엑스트리 들고 있는데 여기 이제 일 안영이라고 들고 있는 거야. 그 이제 내가 일 안영이라고 들고 있으니까 이거를 버전은 로컬에서도 관리를 해야 되거든요. 버전 원이라고 이렇게 관리를 해요. 그리고 나서 이거를 이제 중앙 저장소에 올리는 거죠? 이걸 이제 기덤이라고 생각하시면 돼요. 그래서 기덤에다가 올려요. 금 얘가 일 안영 이 그니까 바이 원정 티 엑스티가 얘가 올라오면서 그 내용이 일 안념 이러고 해서 이걸 버전 원이라고 하는 거에요. 첫 번째 버 하나 피워놨죠. 자 이 상태에서 이제 얘가 이걸 내려가 듣게 되면 얘가 내려가 될 때는 따른 애가 파이 원점 티엑스트를 내려 받는 거 마찬가지인데 얘가 파이 원점 티엑스트 있는 안령이라는 요 메세지만 가지고 있는 게 아니라 버전 원이라는 걸 같이 울고 있어요. 저 요 상태에서 이제 봐봐요. 이 두 번째가 이 반가우라고 적잖아요. 그러면 이걸 그냥 덮어 씌우는 게 아니라 무조건 버전 투로 버전을 여기서 로컬에서 관리를 해줘야 돼요. 버전 투를 만들고 나서 이제 어 올리는 거죠. 자 올리게 되면 이제 파일 원에 대한 내용이 바뀌잖아요? 그면 이걸 이제 인덱스라고 하는데 어떤 목차라고 하는데 파일 일 점 티스틱 하나 더 생기면서 기존에 있는 게 사라지겠죠? 사라지지만 사라지면서 얘가 이제 일 안영에 이 반가워라고 해서 일 버전 투라고 해요. 이 버전 투를 들고 있는 거죠. 실제로는 이 안령이라는 데이터 자체는요 중복이 되지 않아요. 이거는 어차피 이거 레퍼런스만 참조하는 거기 때문에 이 데이터가 중복되진 않구요. 그냥 눈으로 보기에는 이렇게 보인다는 거죠. 자 이 상태에서 이제 얘가 다운을 내려봤잖아요. 두 번째가 이걸 이제 내려받게 되면 얘는 어떻게 데이터를 내려받냐면 파일 원점 티엑스티에 대한 내용이 바뀌겠죠. 얘가 아니라 통으로 바뀌고 그래요. 통으로. 파일 원점 티 엑스티는 일 안령에 이 반거 이렇게 금 얘는 이제 버전투잖아요. 그리고 얘를 통으로 관리하고 있습니다. 결국 히스토리를 다 들고 있는 거죠 얘는 버전원 버전투 얘도 마찬가지죠. 버전 원 버전 투 그리고 얘도 버전 원 버전 투 직 분산 버전 관리 시스템은요. 로콜도 히스토리를 다 들고 있어. 얘도 히스토리도 들고 있고 얘도 히스토리를 들고 있기 때문에 장점이 뭐냐면 얘가 망가지잖아요. 괜찮아요. 왜냐면 히스토리를 통해서 로콜에서 복구하는 게요. 중앙조장소래. 엄청난 거에요. 왜냐면 예전에는 여기서는 내가 뭔가 하나를 반영할라면 항상 중앙조장소에다가 업로드를 해야 되거든요. 그래서 이제 관리를 할 수 있거든요. 업로드를 하면서 관리를 하는 거에요. 근데 이 관리 자체를 이제 로콜에서 할 수 있으니까 말 그대로 인터넷이 안 돼도 내 내부에서 내 컴퓨터 내부에서 로콜로 관리하다가 필요할 때 업로도 하면 돼요 위에다가. 이해 되시나요? 이게 분산 버전 관리 시스템이야 그러면 이제 이게 헷갈릴 거예요 궁금한 게 뭐냐면 어 도대체 얘네들은 같은 파일이 있는데 이 같은 파일에 대한 이 관리를 어떤 방식으로 하는지 이게 궁금하죠. 그쵸 이거에 대한 비밀은 다음 시간에 배워보도록 할게요. 여기서는 이제 핵심은 그거에요. 분산 버전 관리 시스템은 히스토리를 로컬도 가지고 있다는 거예요. 네. 수고하했습니다.


whisper-small-ko-ksponspeech-encoder-freeze-1e-5/checkpoint-9500
Best Decoding Strategy
자 이번 시간에는 그 분산 버전 관리 시스템에 대해서 이해를 해 볼게요. 이 전 시간에 배운 게 협업을 위해서 cv 기억나세요? cvcs라고 해서 그 중앙 관리 중앙에서 관리하는 시스템 이거를 전 시간에 배웠어요. 인제 이게 협업이 되는데 단점은 뭐냐면 중앙 저장소고 고장이 나면 이 협업이 안 돼요. 그리고 얘는 이제 제이 마지막 끝점이라고 하는데 엔드포인트 이 끝점만 이 변경을 기록하기 때문에 끝점에 대한 변경을 기록한다는 게 무슨 말이냐면 봐봐요. 내가 이제 파일 일 점 티엑티가 있는데 여기 내용이 일 안녕? 이렇게 적혀 있는 거에요. 그리고 이제 따른 사람도 이거 같이 놀고 있어요. 자 이 상태에서 이제 내가 여기 cvcs 이 저장소에다가 이 중앙 저장소에다가 얘를 넣어논 거죠. 이 점틱스티래. 그래서 얘를 버전 우원이라고 하는 거예요. 금 얘도 이제 이걸 다운받아가지고 동기화가 돼 있는 상태거든요? 짜 이 상태에서 내가 이제 데이터를 변경을 할 건데 이 방거어라는 데이터를 만들었어요. 그리고 나서 이제 올리게 되면 얘는 마일 일이 이게 업데이트가 돼서 얘가 날라가고 얘를 버전 틀어 가는 거죠. 대신에 이 중앙조장서는 내부 디비를 두고 있어서 히스토리를 가지고 있어요. 히스토리. 히스토리는 원래는 일 안영이었는데 이제 일 안영에 이 반가워가 들어왔다는 이 스토리를 들고 있어. 근데 얘네들은 그런 히스토리를 안 들고 있거든. 얘도 몰라요. 그 히스토리를. 얘는 왜 모르냐면 이제 얘가 이제 반가워를 업로드해서 얘가 반가워 데이터가 됐잖아요? 금 얘가 이제 이걸 렛을 받으면 그냥 이 파일이 점 티 엑스티가 이 덮어 씌워지는 개념이거든요. 덮어 쓰기를 한다는 개념이에요. 그럼 얘는 이제 뭐라 안고 안 되고 있냐면 히스토리는 안 되고 있는 거죠. 이게 없다는 거예요. 얘도 없다는 거죠. 근데 이제 dvcs 분산 버전 관리 시스템은요. 이거는 좀 다른 게 에가 이제 바이 원점 디엑스트리 들고 있는데 여기 이제 일 안영이라고 들고 있는 거예요. 그면 이제 내가 일 안영이라고 들고 있는 거야. 그럼 이제 내가 일 안영이라고 들고 있으니까 이거를 버전은 로컬에서도 관리를 해야 되거든요. 버전 원이라고 이렇게 관리를 해요. 그리고 나서 이거를 이제 중앙 저장소에 올리는 거죠? 이걸 이제 기덤이라고 생각하시면 돼요. 그래서 기덤에다가 올려요. 그면 얘가 일 안녕 이 그니까 바일 원정 티 엑스티가 얘가 올라오면서 그 내용이 일 안녕이라고 해서 이걸 버전 원이라고 하는 거에요. 첫 번째 버전 피워놨죠. 자 이 상태에서 이제 얘가 이걸 내려가 듣게 되면 얘가 내려가 될 때는 따른 애가 파이 원점 티엑스트를 내려 받는 거 마찬가지인데 얘가 파이 원점 티엑스트 있는 안령이라는 요 메세지만 가지고 있는 게 아니라 버전 원이라는 걸 같이 울고 있어요. 저 요 상태에서 이제 봐봐요. 이 두 번째가 이 반가우라고 적잖아요? 그러면 이걸 그냥 덮어 씌우는 게 아니라 무조건 버전 투로 버전을 여기서 로컬에서 관리를 해줘야 돼요. 버전 투를 만들고 나서 이제 어 올리는 거죠. 자 올리게 되면 이제 파일 원에 대한 내용이 바뀌잖아요? 그면 이걸 이제 인덱스라고 하는데 어떤 목차라고 하는데 파일 일 점 티스틱 하나 더 생기면서 기존에 있는 게 사라지겠죠? 사라지지만 사라지면서 얘가 이제 일 안영에 이 반가워라고 해서 일 버전 투라고 해요. 이 버전 투를 들고 있는 거죠. 실제로는 이 안영이라는 데이터 자체는요 중복이 되지 않아요. 이거는 어차피 이거 레퍼런스만 참조하는 거기 때문에 이 데이터가 중복되진 않구요. 그냥 눈으로 보기에는 이렇게 보인다는 거죠. 자 이 상태에서 이제 얘가 다운을 내려봤잖아요. 두 번째가 이걸 이제 내려받게 되면 얘는 어떻게 데이터를 내려받냐면 파일 원점 티엑스티에 대한 내용이 바뀌겠죠. 얘가 아니라 통으로 바뀌고 그래요. 통으로. 파일 원점 티 엑스티는 일 안영에 이 반거 이렇게 금 얘는 이제 버전 투잖아요. 그리고 얘를 통으로 관리하고 있습니다. 결국 히스토리를 다 들고 있는 거죠 얘는 버전 원 버전 투�도 마찬가지죠. 버전 원 버전 투 그리고 얘도 버전 원 버전 투 직 분산 버전 관리 시스템은요. 로콜도 히스토리를 다 들고 있어. 얘도 히스토리도 들고 있고 얘도 히스토리를 들고 있기 때문에 장치가 뭐냐면 얘가 망가지잖아요. 괜찮아요. 왜냐면 히스토리를 통해서 로콜에서 복구하는 게요. 중앙조장소래. 엄청난 거에요. 왜냐면 예전에는 여기서는 내가 뭔가 하나를 반영할려면 항상 중앙조장소에다가 업로드를 해야 되거든요? 그래서 이제 관리를 할 수 있거든요. 업로드를 하면서 관리를 하는 거에요. 근데 이 관리 자체를 이제 로콜에서 할 수 있으니까 말 그대로 인터넷이 안 돼도 내 내부에서 내 컴퓨터 내부에서 로콜로 관리하다가 필요할 때 업로도 하면 돼요. 위에다가 이해되시나요? 이게 분산 버전 관리 시스템이야. 그러면 이제 이게 헷갈릴 거예요. 궁금한 게 뭐냐면 어 도대체 얘네들은 같은 파일이 있는데 이 같은 파일에 대한 이 관리를 어떤 방식으로 하는지 이게 궁금하죠. 그쵸? 이거에 대한 비밀은 다음 시간에 배워보도록 할게요. 여기서는 이제 핵심은 그거에요. 분산 버전 관리 시스템은 히스토리를 로컬도 가지고 있다는 거에요. 네. 수고했습니다.


whisper-small-ko-ksponspeech-encoder-freeze-1e-5-9500-repeat-1e-6/checkpoint-150
Default Decoding Strategy
자 이번 시간에는 그 분산 버전 관리 시스템에 대해서 이해를 해보께요 이 전 시간에 배운 게 협업을 위해서 cv 기억나세요? cvcs라고 해서 그 중앙 관리 중앙에서 관리하는 시스템 이거를 전 시간에 배웠어요 이제 이게 협업이 되는데 단점은 뭐냐면 중앙 저장소고 고장이 나면 이 협업이 안 돼요. 그리고 얘는 이제 제이 마지막 끝점이라고 하는데 엔드포인트 이 끝점만 이 변경을 기록하기 때문에 끝점에 대한 변경을 기록한다는 게 무슨 말이냐면 봐봐요 내가 이제 파일 일 점 티엑티가 있는데 여기 내용이 일 안녕 이렇게 적혀 있는 거에요 그리고 이제 따른 사람도 이거 같이 돌고 있어요 자 이 상태에서 이제 내가 여기 cvcs 이 저장소에다가 이 중앙 저장소에다가 얘를 넣어논 거죠 이 점 택스트를 그래서 얘를 버전 우원이라고 하는 거예요 그럼 얘도 이제 이걸 다운받아가지고 동기화가 돼 있는 상태거든요? 짜 이 상태에서 내가 이제 데이터를 변경을 할 건데 이 반거어라는 데이터를 만들었어요. 그리고 나서 이제 올리게 되면 얘는 마일 일이 이게 업데이트가 돼서 얘가 날라가고 얘를 버전 틀어하는 거죠. 응 대신에 중앙조장서는 내부 디비를 두고 있어서 히스토리를 가지고 있어 히스토리 히스토리는 원래는 일 안영이었는데 이제 일 안영에 이 반가워가 들어왔다는 이 스토리를 들고 있어 근데 얘네들은 그런 히스토리를 안 들고 있거든 얘 얘도 몰라요 그 히스토리를 얘는 왜 모르냐면 이제 얘가 이제 반가워를 업로드해서 얘가 반가워 데이터가 됐잖아요? 그면 얘가 이제 이걸 뇌를 받으면 그냥 이 파일 이 점 티 엑스티가 이 덮어 씌워지는 개념이거든요. 덮어 쓰기를 한다는 개념이에요. 그럼 얘는 이제 뭐라 안고 안 되고 있는 희스토리는 안 되고 있는 거죠. 이게 없다는 거예요. 얘도 없다는 거죠. 근데 이제 dvcs 분산 버전 관리 시스템은요. 이거는 좀 다른 게 얘가 이제 파일 원점 티 엑스트리 들고 있는데 여기 이제 일 안영이라고 들고 있는 거야. 그 이제 내가 일 안령이라고 두고 있으니까 이거를 버전은 로컬에서도 관리를 해야 되거든요. 버전 원이라고 이렇게 관리를 해요. 그리고 나서 이거를 이제 중앙저장소에 올리는 거죠? 이거를 이제 기덤이라고 생각하시면 돼요. 그래서 기덤에다가 올려요. 금 얘가 일 안령 이 그니까 바이 원정TXT가 얘가 올라오면서 그 내용이 일 안념이라고 해서 이걸 버전 원이라고 하는 거야 첫 번째 버전이이 하나 피워놨죠. 자 이 상태에서 이제 얘가 이걸 내려가 듣게 되면 얘가 내려가 될 때는 따른 애가 파이 원점 티엑스트를 내려가는 거 마찬가지인데 얘가 파이 원점 티엑스트는 안령이라는 요 메세지만 가지고 있는 게 아니라 버전 원이라는 걸 같이 요고 있어요. 저 요 상태에서 이제 봐봐요 이 두 번째가 이 반가우라고 적잖아요 그러면 이걸 그냥 덮어 씌우는 게 아니라 무조건 버전 투로 버전을 여기서 로커를 해서 관리를 해줘야 돼요 버전 투를 만들고 나서 이제 어 올리는 거죠 자 올리게 되면 이제 파일 원에 대한 내용이 바뀌잖아요? 그면 이걸 이제 인덱스라고 하는데 어떤 목차라고 하는데 파일 일 점 티스트가 하나 더 생기면서 기존에 있는 게 사라지겠죠 사라지지만 사라지면서 얘가 이제 일 안녕에 이 반가워라고 해서 일 버전 투라고 해요 이 버전 투를 들고 있는 거죠 실제로는 이 안령이라는 데이터 자체는요 중독이 되지 않아요 이거는 어차피 이거 레퍼런스만 참조하는 거기 때문에 이 데이터가 중독되진 않구요 그냥 눈으로 보기에는 이렇게 보긴다는 거죠 자 이 상태에서 이제 얘가 다운을 내려봤잖아요 두 번째가 이걸 이제 내려받게 되면 얘는 어떻게 데이터를 내려받냐면 파일 원점 티엑티에 대한 내용이 바뀌겠죠 얘가 아니라 통으로 바뀌고 그래요 통으로 파점 티 엑스티는 일 안녕해 이 반거 이렇게 금 얘는 이제 버전 투잖아요 그리고 얘를 통으로 관리하고 있습니다 결국 히스토리를 다 들고 있는 거죠 얘는 버전 원 버전 투 얘도 마찬가지죠 버전 원 버전 투 그리고 얘도 버전 원 버전 투 직 분산 버전 관리 시스템은요 로콜도 히스토리를 다 두고 있어 얘도 히스토리도 두고 있고 얘도 히스토리를 두고 있기 때문에 장점이 뭐냐면 얘가 망가지잖아요? 괜찮아요 왜냐면 히스토리를 통해서 로콜에서 복구구하는 게요 중앙조정서래 엄청난 거에요. 왜냐면 예전에는 여기서는 내가 뭔가 하나를 반영할라면 항상 중앙조정서에다가 업로드를 해야 되거든요? 그래서 이제 관리를 할 수 있거든요. 업로드를 하면서 관리를 하는 거에요. 근데 이 관리 자체를 이제 로코를 할 수 있으니까 말 그대로 인터넷이 안 돼도 내 내부에서 내 컴퓨터 내부에서 로콜로 관리하다가 필요할 때 업로도 하면 돼요 위에다가 이해되시나요? 이게 분산 버전 관리 시스템이야 그러면 이제 이게 헷갈릴 거예요 궁금한 게 뭐냐면 어 도대체 얘네들은 같은 파일이 있는데 이 같은 파일에 대한 이 관리를 어떤 방식으로 하는지 이게 궁금하죠 그쵸 이거에 대한 비밀은 다음 시간에 배워보도록 할게요 여기서는 이제 핵심은 그거에요 분산 버전 관리 시스템은 히스토리를 로컬도 가지고 있다는 거예요 네 수고하 있습니다


whisper-small-ko-ksponspeech-encoder-freeze-1e-5-9500-repeat-1e-6/checkpoint-150
Best Decoding Strategy
자 이번 시간에는 그 분산 버전 관리 시스템에 대해서 이해를 해보께요. 이 전 시간에 배운 게 협업을 위해서 cv 기억나세요? cvcs라고 해서 그 중앙 관리 중앙에서 관리하는 시스템 이거를 전 시간에 배웠어요. 이제 이게 협업이 되는데 단점은 뭐냐면 중앙 저장소고 고장이 나면 이 협업이 안 돼요. 그리고 얘는 이제 제이 마지막 끝점이라고 하는데 엔드포인트 이 끝점만 이 변경을 기록하기 때문에 끝점에 대한 변경을 기록한다는 게 무슨 말이냐면 봐봐요 내가 이제 파일 일 점 티엑티가 있는데 여기 내용이 일 안녕 이렇게 적혀 있는 거에요 그리고 이제 따른 사람도 이거 같이 놀고 있어요 자 이 상태에서 이제 내가 여기 cvcs 이 저장소에다가 이 중앙 저장소에다가 얘를 넣어논 거죠? 이 점 택스트를 그래서 얘를 버전 우원이라고 하는 거예요. 금 얘도 이제 이걸 다운받아가지고 동기화가 돼 있는 상태거든요? 짜 이 상태에서 내가 이제 데이터를 변경을 할 건데 이 반거어라는 데이터를 만들었어요. 그리고 나서 이제 올리게 되면 얘는 마일 일이 이게 업데이트가 돼서 얘가 날라가고 얘를 버전 틀어하는 거죠. 응 대신에 중앙조장서는 내부 디비를 두고 있어서 히스토리를 가지고 있어 히스토리 히스토리는 원래는 일 안영이었는데 이제 일 안영에 이 반가워가 들어왔다는 히스토리를 들고 있어 근데 얘네들은 그런 히스토리를 안 들고 있거든 얘 얘도 몰라요 그 히스토리를 얘는 왜 모르냐면 이제 얘가 이제 반가워를 업로드해서 얘가 반가워 데이터가 됐잖아요? 그면 얘가 이제 이걸 내려받으면 그냥 이 파일 이 점 티 엑스티가 이 덮어 씌워지는 개념이거든요. 덮어 쓰기를 한다는 개념이에요. 그럼 얘는 이제 뭐라 안고 안 되고 있냐면 히스토리는 안 되고 있는 거죠. 이게 없다는 거에요. 얘도 없다는 거죠. 근데 이제 dvcs 분산 버전 관리 시스템은요 이거는 좀 다른 게 에가 이제 파일 원점 티 엑스트를 들고 있는데 여기 이제 일 안영이라고 들고 있는 거에요. 그면 이제 내가 일 안영이라고 두고 있는 거야. 그 이제 내가 일 안영이라고 두고 있으니까 이거를 버전은 로컬에서도 관리를 해야 되거든요. 버전 원이라고 이렇게 관리를 해요. 그리고 나서 이거를 이제 중앙 저장소에 올리는 거죠? 이걸 이제 기덤이라고 생각하시면 돼요. 그래서 기덤에다가 올려요. 그면 얘가 일 안녕 이 그니까 바이 원정 티 엑스티가 얘가 올라오면서 그 내용이 일 안녕 이러고 해서 이걸 버전 원이라고 하는 거죠. 첫 번째 버전이 하나 피워놨죠. 자 이 상태에서 이제 얘가 이걸 내려가 듣게 되면 얘가 내려가 될 때는 따른 애가 파이 원점 티엑스트를 내려가는 건 마찬가지인데 얘가 파이 원점 티엑스트 있는 안녕이라는 요 메세지만 가지고 있는 게 아니라 버전 원이라는 걸 같이 우고 있어요. 저 요 상태에서 이제 봐봐요 이 두 번째가 이 반가우라고 적잖아요 그러면 이걸 그냥 덮어 씌우는 게 아니라 무조건 버전 투로 버전을 여기서 로컬해서 관리를 해줘야 돼요 버전 투를 만들고 나서 이제 어 올리는 거죠 자 올리게 되면 이제 파일 원에 대한 내용이 바뀌잖아요? 그면 이걸 이제 인덱스라고 하는데 어떤 목차라고 하는데 파일 일 점 틱스틱 하나 더 생기면서 기존에 있는 게 사라지겠죠? 사라지지만 사라지면서 얘가 이제 일 안녕에 이 이 반가워라고 해서 일 버전 투라고 해요 이 버전 투를 들고 있는 거죠 실제로는 이 안영이라는 데이터 자체는요 중복이 되지 않아요 이거는 어차피 이거 레퍼런스만 참조하는 거기 때문에 이 데이터가 중복되진 않구요 그냥 눈으로 보기에는 이렇게 보긴다는 거죠 자 이 상태에서 이제 얘가 다운을 내려봤잖아요 두 번째가 이걸 이제 내려받게 되면 얘는 어떻게 데이터를 내려받냐면 파일 원점 티엑티에 대한 내용이 바뀌겠죠 얘가 아니라 통으로 바뀌고 그래요 통으로 파일 원점 티 엑스티는 일 안녕해 이 반거 이렇게 금 얘는 이제 버전 투잖아요 그리고 얘를 통으로 관리하고 있습니다 결국 히스토리를 다 들고 있는 거죠 얘는 버전 원 버전 투 얘도 마찬가지죠 버전 원 버전 투 그리고 얘도 버전 원 버전 투 직 분산 버전 관리 시스템은요 로콜도 히스토리를 다 두고 있어 얘도 히스토리도 두고 있고 얘도 히스토리를 두고 있기 때문에 장점이 뭐냐면 얘가 망가지잖아요? 괜찮아요 왜냐면 히스토리를 통해서 로콜에서 복구구하는 게요 중앙조정서래 엄청난 거에요. 왜냐면 예전에는 여기서는 내가 뭔가 하나를 반영할라면 항상 중앙조정서에다가 업로드를 해야 되거든요? 그래서 이제 관리를 할 수 있거든요. 업로드를 하면서 관리를 하는 거에요 근데 이 관리 자체를 이제 로코레이션 할 수 있으니까 말 그대로 인터넷이 안 돼도 내 내부에서 내 컴퓨터 내부에서 로콜로 관리하다가 필요할 때 업로도 하면 돼요 위에다가 이해되시나요? 이게 분산 버전 관리 시스템이야 그러면 이제 이게 헷갈릴 거예요 궁금한 게 뭐냐면 어 도대체 얘네들은 같은 파일이 있는데 이 같은 파일에 대한 이 관리를 어떤 방식으로 하는지 이게 궁금하죠 그쵸 이거에 대한 비밀은 다음 시간에 배워보도록 할게요 여기서는 이제 핵심은 그거에요 분산 버전 관리 시스템은 히스토리를 로컬도 가지고 있다는 거에요 네 수고했습니다


